/**
 * Sprite Sheet Generator
 * Combines individual sprite images into a single atlas with JSON metadata
 */

import fs from "fs";
import path from "path";
import { PNG } from "pngjs";

const SPRITES_DIR = "./src/images/sprites";
const OUTPUT_IMAGE = "./public/images/spritesheet.png";
const OUTPUT_JSON = "./src/sprites/spritesheet-data.ts";
const PADDING = 2;

// Get all PNG files in the sprites directory
function getSpritePaths() {
  const files = fs.readdirSync(SPRITES_DIR);
  return files
    .filter((f) => f.endsWith(".png"))
    .map((f) => ({
      id: f.replace(".png", ""),
      path: path.join(SPRITES_DIR, f),
    }));
}

// Load a PNG file
function loadPNG(filePath) {
  return new Promise((resolve, reject) => {
    fs.createReadStream(filePath)
      .pipe(new PNG())
      .on("parsed", function () {
        resolve(this);
      })
      .on("error", reject);
  });
}

// Shelf packing algorithm
function packSprites(sprites, maxWidth = 2048) {
  // Sort by height descending for better packing
  const sorted = [...sprites].sort((a, b) => b.height - a.height);

  let shelfY = PADDING;
  let shelfHeight = 0;
  let currentX = PADDING;
  let maxY = 0;
  let usedWidth = 0;

  const placements = new Map();

  for (const sprite of sorted) {
    // Check if sprite fits on current shelf
    if (currentX + sprite.width + PADDING > maxWidth) {
      // Move to next shelf
      shelfY += shelfHeight + PADDING;
      shelfHeight = 0;
      currentX = PADDING;
    }

    // Place sprite
    placements.set(sprite.id, {
      x: currentX,
      y: shelfY,
      w: sprite.width,
      h: sprite.height,
    });

    currentX += sprite.width + PADDING;
    shelfHeight = Math.max(shelfHeight, sprite.height);
    maxY = Math.max(maxY, shelfY + sprite.height);
    usedWidth = Math.max(usedWidth, currentX);
  }

  // Round up to power of 2 for GPU efficiency
  const atlasWidth = nextPowerOf2(usedWidth);
  const atlasHeight = nextPowerOf2(maxY + PADDING);

  return { placements, atlasWidth, atlasHeight };
}

function nextPowerOf2(n) {
  let power = 1;
  while (power < n) power *= 2;
  return power;
}

// Copy pixels from source to destination
function copyPixels(src, dst, srcX, srcY, dstX, dstY, width, height) {
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const srcIdx = ((srcY + y) * src.width + (srcX + x)) * 4;
      const dstIdx = ((dstY + y) * dst.width + (dstX + x)) * 4;
      dst.data[dstIdx] = src.data[srcIdx];
      dst.data[dstIdx + 1] = src.data[srcIdx + 1];
      dst.data[dstIdx + 2] = src.data[srcIdx + 2];
      dst.data[dstIdx + 3] = src.data[srcIdx + 3];
    }
  }
}

async function main() {
  console.log("Loading sprites...");

  const spritePaths = getSpritePaths();
  const sprites = [];

  for (const { id, path: spritePath } of spritePaths) {
    try {
      const png = await loadPNG(spritePath);
      sprites.push({
        id,
        png,
        width: png.width,
        height: png.height,
      });
      console.log(`  Loaded: ${id} (${png.width}x${png.height})`);
    } catch (err) {
      console.error(`  Failed to load: ${id}`, err.message);
    }
  }

  console.log(`\nPacking ${sprites.length} sprites...`);

  const { placements, atlasWidth, atlasHeight } = packSprites(sprites);

  console.log(`Atlas size: ${atlasWidth}x${atlasHeight}`);

  // Create output PNG
  const atlas = new PNG({ width: atlasWidth, height: atlasHeight });

  // Initialize to transparent
  for (let i = 0; i < atlas.data.length; i += 4) {
    atlas.data[i] = 0;
    atlas.data[i + 1] = 0;
    atlas.data[i + 2] = 0;
    atlas.data[i + 3] = 0;
  }

  // Copy sprites to atlas
  for (const sprite of sprites) {
    const placement = placements.get(sprite.id);
    copyPixels(
      sprite.png,
      atlas,
      0,
      0,
      placement.x,
      placement.y,
      sprite.width,
      sprite.height
    );
  }

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_IMAGE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write atlas image
  console.log(`\nWriting atlas image to ${OUTPUT_IMAGE}...`);
  const buffer = PNG.sync.write(atlas);
  fs.writeFileSync(OUTPUT_IMAGE, buffer);

  // Generate TypeScript data file
  console.log(`Writing frame data to ${OUTPUT_JSON}...`);

  const frameEntries = [];
  for (const [id, frame] of placements) {
    frameEntries.push(`  ${id}: { x: ${frame.x}, y: ${frame.y}, w: ${frame.w}, h: ${frame.h} }`);
  }

  const tsContent = `/**
 * Auto-generated sprite sheet frame data
 * Generated by scripts/generate-spritesheet.js
 */

export const SPRITESHEET_PATH = "/images/spritesheet.png";

export const SPRITESHEET_SIZE = {
  width: ${atlasWidth},
  height: ${atlasHeight},
};

export interface SpriteFrame {
  x: number;
  y: number;
  w: number;
  h: number;
}

export const SPRITESHEET_FRAMES: Record<string, SpriteFrame> = {
${frameEntries.join(",\n")}
};
`;

  fs.writeFileSync(OUTPUT_JSON, tsContent);

  console.log("\nDone!");
  console.log(`  Atlas: ${atlasWidth}x${atlasHeight} pixels`);
  console.log(`  Sprites: ${sprites.length}`);
}

main().catch(console.error);
